/* ==========================================================================
   Sidebar, page, etc. navigation and visualization helper scripts
   ========================================================================== */

$(function () {
  const notFoundPageName = '404.html';
  const contentID = 'article';

  function trimCharFromString(str, char) {
    // Create a regular expression to match the given character at the beginning or end of the string
    const regex = new RegExp(`^${char}|${char}$`, 'g');

    // Use replace() to trim the character from the string
    return str.replace(regex, '');
  }

  function hideTocIfNotNeeded(docObject, forceHide) {
    var shouldHide = forceHide;
    var tocElement = docObject.querySelector('.toc');

    if (tocElement) {
      var tocMenuElement = tocElement.querySelector('.toc__menu');
      if (null == tocMenuElement || false == tocMenuElement.hasChildNodes)
        shouldHide = true;
      if (shouldHide) {
        // TOC is autogenerated via 'include toc.html' so its size is not known prior the call of toc.html
        // Signal emptiness, css will hide if needed based on it and config settings
        // NOTE: Not hiding directly here to behave the same way like the left sidebar does
        tocElement.classList.add('empty');
      }
    }
  }

  function adjustSidebars() {
    // Identify the URL of the loaded page
    var loadedPageUrl = window.location.pathname;

    // Get the "sidebar" element
    var sidebarElement = document.querySelector('.sidebar');
    // If "sidebar" element exists, find the corresponding navigator item within it
    if (sidebarElement) {
      // Get all <a> elements in the navigation list within the "sidebar"
      var navLinks = sidebarElement.querySelectorAll('.nav__list .nav-link');

      // Enumerate through each <a> element and remove the "active" class
      navLinks.forEach(navLink => {
        navLink.classList.remove('active');
      });

      // Find the corresponding navigator item with matching URL within the "sidebar"
      var matchingNavItem = sidebarElement.querySelector('.nav__list .nav-link[href="' + loadedPageUrl + '"]');

      // If a matching item is found, mark it as "active"
      if (matchingNavItem) {
        matchingNavItem.classList.add('active');

        // Sync the browser title too
        title = matchingNavItem.text;
        if (title)
          window.top.document.title = title;

        // Expand all parent ul elements up to the nearest .nav__list
        var parentUl = matchingNavItem.closest('ul');
        while (parentUl) {
          var parentCheckbox = parentUl.previousElementSibling.previousElementSibling;
          if (parentCheckbox && parentCheckbox.tagName === 'INPUT' && parentCheckbox.type === 'checkbox')
            parentCheckbox.checked = true;

          // Check if we reached the top most list container item that is an <ul> with class 'nav__list'
          var immediateParent = parentUl.parentElement;
          if (immediateParent.classList.contains('nav__list'))
            break;

          parentUl = immediateParent.closest('ul');
        }

        // Ensure the active item is visible within the "sidebar"
        // TODO: This one is also not too reliable, browser dependant, get a better solution
        matchingNavItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }

      hideTocIfNotNeeded(document, false);
    }
  }

  // -------------
  // Function to load content based on relative URL
  // -------------
  function loadContentFromUrl(url, onSuccess, onError) {
    fetch(url)
      .then(response => {
        if (false == response.ok) {
          if (response.status == 404 && url.toLowerCase().indexOf(notFoundPageName) === -1)
            throw new Error(response.status);
          else
            throw new Error('Server returned ' + response.status);
        }
        return response.text();
      })
      .then(html => {
        // Parse the HTML string to create a DOM document
        var parser = new DOMParser();
        var doc = parser.parseFromString(html, 'text/html');
        // Find the "article" element in the parsed document
        var newContent = doc.querySelector(contentID);
        onSuccess(newContent);
      })
      .catch(error => {
        onError(error);
      });
  }

  function scrollToAnchor(anchorId) {
    var anchorElement = document.getElementById(anchorId);
    if (anchorElement) {
      // Use the attached smooth scroll to have a consistent behavior
      smoothScroll.animateScroll(anchorElement, null, { updateURL: false });
    }
  }

  function anchorIDFromUrl(url) {
    var anchorId = null;
    var hash = url.hash;
    if (hash && hash.length > 0) {
      var hashIndex = hash.indexOf('#');
      if (hashIndex !== -1)
        anchorId = hash.substring(hashIndex + 1);
    }
    return anchorId;
  }

  // Function to apply all of our custom modifications on the self loaded pages
  function finalizeContent(anchorId) {
    // Sync the sidebar with the current page url, migth be out of sync when the page is loaded initially from an inner url
    adjustSidebars();
    // There might be nav-links in the loaded new content as well (e.g.Next / Prev buttons
    // so, handle the links here as the last action
    updateNavLinks();
    // Add page heading anchors
    addPageAnchors();
    // Add toc to anchor scrolling
    addTOCScrolling();
    // Add code block enhancements
    if (ClipboardJS.isSupported())
      addCodeBlocksTitle();
    // Add content tooltips
    addContentTooltips();
    // Try to scroll to a giben anchor, if any
    if (anchorId)
      scrollToAnchor(anchorId);
    // Clear any focus (e.g back navigation keeps the previously clicked link focused)
    window.trigger('blur');
  }

  function updateContentFromUrl(url) {
    var currContent = document.querySelector(contentID);

    loadContentFromUrl(
      url,
      newContent => {
        // FIXME: This does not work, double check
        currContent.scrollTop;
        // As a workaround of the above, empty the old content, and with a short delay only, load the new one
        currContent.innerHTML = '';

        // Replace the old content, but only with a small delay, to make sure the content reset takes effect
        setTimeout(function () {
          // Replace the old content with the loaded content
          currContent.parentNode.replaceChild(newContent, currContent);

          // Add all our custom modifications to all the self loaded pages
          finalizeContent(anchorIDFromUrl(url));
        }, 100);
      },
      error => {
        if (error == "Error: 404") {
          var baseURL = window.location.origin;
          var notFoundURL = baseURL + '/' + docPrefix() + notFoundPageName;

          updateContentFromUrl(notFoundURL);
        }
        else {
          currContent.innerHTML = '<h3>Sorry, there was a problem loading the content!</h3>(' + error + ')';
          console.error("Error loading content, " + error)
        }
      }
    );
  }

  // -------------
  // Functions to handle link clicks
  // -------------
  function getCollectionFromDocPath(url) {
    var collection = '';
    var parts = trimCharFromString(url.pathname, '/').split('/');

    if (docRoot == '') {
      collection = parts[0];
    }
    else {
      var docIndex = parts.indexOf(docRoot);

      // If 'docRoot' is found or it is not the last segment, return the next part after it as the collection name
      if (docIndex !== -1 && docIndex !== parts.length - 1)
        collection = parts[docIndex + 1];
    }
    return collection;
  }

  function sameCollection(url1, url2) {
    var collection1 = getCollectionFromDocPath(url1);
    var collection2 = getCollectionFromDocPath(url2);

    return collection1 === collection2;
  }

  function handleNavLinkClick(event) {
    if (!event.shiftKey && !event.ctrlKey && !event.altKey && !event.metaKey) {
      if (tooltipTarget)
        hideTooltip(true);

      var updated = false;
      // Get the relative URL value and update the browser URL
      // Use originalTarget or explicitTarget to get the correct one even for clicks from the tooltips
      var anchorElement = event.originalTarget.closest('a');

      if (anchorElement) {
        var url = new URL(anchorElement.href);

        // Try to load into the inner content frame only if the collection has not changed
        // Otherwise let the original click flow take effect, as the nav bar must be reloaded too
        // for a different collection
        if (url.origin === window.location.origin && anchorElement.target !== '_blank' && sameCollection(url, window.location)) {
          // Prevent default navigation behavior, we will use our content load method
          event.preventDefault();

          var urlStr = url.pathname + url.hash;
          updated = (urlStr != window.location.pathname + window.location.hash);

          // Update the browser URL
          history.pushState(null, null, url);

          // Load content based on the updated relative URL
          // but only if the url has changed
          if (updated)
            updateContentFromUrl(url);
        }
        // Clear focus from the clicked element, as we have other visualization for the selected items
        event.target.blur();
      }
      if (false == updated)
        console.debug("Different collection item or new tab/page requested, loading full page...")
    }
  }

  function updateNavLinks(event) {
    // Attach click event listeners to all links with class 'nav-link'
    var navLinks = document.querySelectorAll('.nav-link');
    navLinks.forEach(function (link) {
      link.addEventListener('click', handleNavLinkClick);
    });
  }

  // -------------
  // TOC smooth scrolling
  // -------------
  const smoothScrollTopOffset = 100;
  var smoothScroll = new SmoothScroll('a[href*="#"]', {
    offset: smoothScrollTopOffset,
    speed: 400,
    speedAsDuration: true,
    durationMax: 500
  });

  function addTOCScrolling() {
    // Gumshoe scroll spy init
    if ($("nav.toc a").length > 0) {
      var spy = new Gumshoe("nav.toc a", {
        // Active classes
        navClass: "active", // applied to the nav list item
        contentClass: "active", // applied to the content

        // Nested navigation
        nested: false, // if true, add classes to parents of active link
        nestedClass: "active", // applied to the parent items

        // Offset & reflow
        offset: smoothScrollTopOffset, // how far from the top of the page to activate a content area
        reflow: true, // if true, listen for reflows

        // Event support
        events: true // if true, emit custom events
      });
    }
  }

  // -------------
  // Add anchors for headings
  // -------------
  function addPageAnchors() {
    // FIXME: This magic 6 must be maintained together now with generate_links.rb (and other places ?!), eliminate it!
    $('.page__content').find('h1, h2, h3, h4, h5, h6').each(function () {
      var id = $(this).attr('id');
      if (id) {
        var anchor = document.createElement("a");
        anchor.className = 'header-link';
        anchor.href = '#' + id;
        anchor.innerHTML = '<span class=\"sr-only\">Permalink</span><i class=\"fab fa-slack-hash\"></i>';
        anchor.title = "Permalink";
        $(this).append(anchor);
      }
    });
  }

  // To support page links even better if possible in case the page has no description / subtitle, but has some text 
  // right after the title and before the first heading is presented, it will be treated as the description and will be handled here.
  // This part should also handle the case when only the title presented. (a.k.a. not showing the tooltip in that case),
  // also responsible to create a uniform look and fell both for page title tooltips and other link tooltips. 
  //
  function alterContentForTooltip(content, url, isFullPageContent, isTextTooltip) {
    var newContent = null;

    if (isTextTooltip) {
      // This would give the saem result as for the other tooltip contents
      // but this kind of tooltip close to a real, one liner tooltip
      // <p> would add huge paddings around it
      // TODO: Add a better, musch more tiny tooltip look
      // newContent = "<p>" + content + "</p>";
      newContent = content;
    }
    else {
      let tempContainer = document.createElement('div');
      tempContainer.innerHTML = content;

      hideTocIfNotNeeded(tempContainer, true);

      // Remove/Override some default title style formatting to look better in the tooltip
      var pageTitle = tempContainer.querySelector('#page-title');
      if (pageTitle == null) {
        // If there is no page title, replace the first heading with an item looks and behaves like the page title
        // to have similar result both for page title tooltips and other link item tooltips
        // FIXME: This magic 6 must be maintained together now with generate_links.rb (and other places ?!), eliminate it!
        var firstHeading = tempContainer.querySelector("h2, h3, h4, h5, h6");
        if (firstHeading) {
          // Everything bellow must exist, so intentionally there's no error handling, let it rise
          pageTitle = document.querySelector('#page-title').cloneNode(true);
          pageTitle.id = firstHeading.id;

          const anchorElement = pageTitle.querySelector("a");
          anchorElement.textContent = firstHeading.textContent;
          anchorElement.href = url;

          tempContainer.replaceChild(pageTitle, firstHeading);
        }
      }
      pageTitle.style.marginTop = '1em';

      newContent = tempContainer.innerHTML
      // remove unnecessary, reqursive inner content tooltips
      newContent = newContent.replace(/\bcontent-tooltip\b/g, '');
    }

    return newContent;
  }

  function loadContentPartFrom(url, onSuccess, onError) {
    // If no anchor with heading id, use the page title with id=""
    var startHeadingId = 'page-title'
    // Extract the anchor part of the URL
    var hashIndex = url.indexOf('#');
    var hasAnchor = (hashIndex !== -1);

    if (hasAnchor)
      startHeadingId = url.substring(hashIndex + 1);

    loadContentFromUrl(
      url,
      newContent => {
        var startHeading = newContent.querySelector('#' + startHeadingId);
        if (startHeading) {
          var content = '';
          var heading = startHeading.outerHTML; // Include the starting <h> element itself
          var nextSibling = startHeading.nextElementSibling;

          // If handling a page title it will not have next sibling normally at all (we are removed and handling differently the description from the generated page)
          // In that case the description is all the normal texts parts in the content, from the top (right bellow the title) to the first heading <h1-6>, try to get, it if there's any.
          // If not presented, drop the whole content, return an empty one (a.k.a. do not show title only tooltips)
          if (nextSibling == null && false == hasAnchor) {
            startHeading = newContent.querySelector('.page__content');
            nextSibling = startHeading.firstElementChild;
            // First element is the TOC, skip it to be able to produce an empty content
            if (nextSibling && nextSibling.classList.contains('sidebar__right'))
              nextSibling = nextSibling.nextElementSibling;
          }
          // Collect all siblings until the next heading or the end of the initial content
          // FIXME: This magic 6 must be maintained together now with generate_links.rb (and other places ?!), eliminate it!
          while (nextSibling && nextSibling.tagName !== 'H1' && nextSibling.tagName !== 'H2' && nextSibling.tagName !== 'H3' && nextSibling.tagName !== 'H4' && nextSibling.tagName !== 'H5' && nextSibling.tagName !== 'H6') {
            content += nextSibling.outerHTML;
            nextSibling = nextSibling.nextElementSibling;
          }
          
          if (content.length != 0 || hasAnchor)
            content = heading + content;

          onSuccess(content);
        }
        else
          onError('Start heading not found by ID: ' + startHeadingId);
      },
      error => {
        onError(error);
      }
    );
  }

  // -------------
  // Tooltip generation and handling
  // -------------
  const toolTipArrowHalfSize = 10; /* $tooltip-arrow-half-size  -> _variables.scss & _navigation.scss - .tooltip:before */
  var contentTooltip = null;
  var tooltipRenderer = null;
  var tooltipTarget = null;
  var tooltipToTargetRelativePosition = null;
  var elementUnderCursor = null;
  var shouldShowTooltip = false;
  var showTimeoutFuncID;
  var hideTimeoutFuncID;

  function setTooltipArrowPosition(posName, position) {
    var newPosition = position + 'px';
    contentTooltip.style.setProperty(posName, newPosition);
  }

  function setTooltipPos(event, tooltipTarget, alignment, isTextTooltip) {
    const targetRect = tooltipTarget.getBoundingClientRect();
    var computedTargetStyle = window.getComputedStyle(tooltipTarget);
    var lineHeight = parseFloat(computedTargetStyle.getPropertyValue('line-height'));
    // NOTE: The content of the targeted tooltip is still not yet calculated correctly here, as it is invisible, and getting visible is animated multiple ways
    //       use, the always visible, not animated at all, but offscreen pair of it (tooltipRenderer) for rendered size calculations.
    //       To get this work all the animation styles must be removed in the css (_navigations.scss) for #tooltipRenderer
    // TODO: Now we have the correct tooltip content via teh tooltipRenderer trick.
    //       Prevent tooltip overflow on window edges in all directions.
    var tooltipRect = tooltipRenderer.getBoundingClientRect();
    var tooltipWidth = tooltipRect.width;
    var pos = new DOMPoint();

    const mouseX = event.clientX;
    var xShift = (alignment == 'tooltip-align-left' ? tooltipWidth : (alignment == 'tooltip-align-center' ? tooltipWidth / 2 : 0));
    pos.x = mouseX; // Use now mouse X instead - Math.max(0, pos.x + document.documentElement.scrollLeft + targetRect.left);
    pos.x -= xShift;
    
    // If the occupied space of the tooltip target is bigger than its line height, it means it spanws to multiple lines
    // align to the upper line part in that case if the mouse is on the right side of the middle of its targetRect, otherwise align to the bottom row part
    var multilineUpperPart = false == isTextTooltip && (targetRect.height > lineHeight && mouseX > targetRect.x + targetRect.width / 2);
    pos.y = pos.y + (hasMastHead ? 0 : document.documentElement.scrollTop) + targetRect.top + targetRect.height / (multilineUpperPart ? 2 : 1);

    var tooltipArrowHorizontalPadding = (4 * toolTipArrowHalfSize) * (alignment == 'tooltip-align-left' ? 1 : (alignment == 'tooltip-align-right' ? -1 : 0));
    setTooltipArrowPosition('--tooltip-arrow-left', xShift - tooltipArrowHorizontalPadding - toolTipArrowHalfSize);
    setTooltipArrowPosition('--tooltip-arrow-top', -1 * toolTipArrowHalfSize);

    var contentTooltipLeft = pos.x + tooltipArrowHorizontalPadding;
    var contentTooltipTop = pos.y + toolTipArrowHalfSize;
    contentTooltip.style.left = contentTooltipLeft + 'px';
    contentTooltip.style.top = contentTooltipTop + 'px';
  }

  function getRealZIndex(element) {
    var zIndex = getComputedStyle(element).zIndex;

    // If the element's z-index is not auto, return it
    if (zIndex !== "auto")
      return parseInt(zIndex);
    else {
      // If the element's z-index is auto, traverse the parent hierarchy
      var parent = element.parentElement;
      var highestZIndex = null;
      while (parent) {
        var parentZIndex = getComputedStyle(parent).zIndex;
        if (parentZIndex !== "auto") {
          var zIndexValue = parseInt(parentZIndex);
          if (highestZIndex === null || zIndexValue > highestZIndex) {
            highestZIndex = zIndexValue;
          }
        }
        parent = parent.parentElement;
      }
      return highestZIndex;
    }
  }

  function setTooltipStyle(alignment, isFullPageContent, isTextTooltip) {
    if (isTextTooltip) {
      contentTooltip.classList.add("text-content-tooltip");
      tooltipRenderer.classList.add("text-content-tooltip");
    }
    else {
      contentTooltip.classList.remove("text-content-tooltip");
      tooltipRenderer.classList.remove("text-content-tooltip");
    }
    if (isFullPageContent) {
      contentTooltip.classList.add("full-content-tooltip");
      tooltipRenderer.classList.add("full-content-tooltip");
    }
    else {
      contentTooltip.classList.remove("full-content-tooltip");
      tooltipRenderer.classList.remove("full-content-tooltip");
    }
    contentTooltip.classList.remove('tooltip-align-left', 'tooltip-align-center', 'tooltip-align-right');
    tooltipRenderer.classList.remove('tooltip-align-left', 'tooltip-align-center', 'tooltip-align-right');
    contentTooltip.classList.add(alignment);
    tooltipRenderer.classList.add(alignment);
  }

  function setTooltipZIndex() {
    var zIndex = getRealZIndex(tooltipTarget);

    if (zIndex)
      contentTooltip.style.zIndex = zIndex;
    else {
      /* If the parent hierarchy has no explicit z-index setting, use a higher than the default
         FIXME: messy, as a deafult is not defined anywhere, only in the (s)css files, 
                add a know global in the _variables.scss and use it here, and everywhere in the scss files where the z-index is set
                (like _magnific-popup,scss does)
         Now, it seems, the 0 is the default and only the following values are used
            - 100000 - screen reader
            - 9999, 999 - modals
            - 1040+ - magnific-popup
            - 20 - skip-link
            - 20, 1 - sidebar author__urls-wrapper
            - 20, 10 - .nav__list .nav__items label
            - 20 - masthead
            - 10 - masthead nav
            - 10 - sidebar__right
            - 10 - archive__item a
            - 5 - archive__item-caption
            - 5 - page__hero-caption
       */
      zIndex = 5;
    }
    /*
     NOTE: Currently we only have to care about tooltips for
           - page content items
                max z-index - 0
           - masthead items (e,g, buttons)
                max z-index - 20
    so, simply currently just setting one higher value for the tooltip than the target. 
    */
    contentTooltip.style.zIndex = zIndex + 1;
  }

  function showTooltip(event, tooltipText, alignment, isFullPageContent, isTextTooltip) {

    contentTooltip.innerHTML = tooltipText.innerHTML;
    tooltipRenderer.innerHTML = contentTooltip.innerHTML;

    setTooltipStyle(alignment, isFullPageContent, isTextTooltip);
    setTooltipZIndex();
    setTooltipPos(event, tooltipTarget, alignment, isTextTooltip);
    
    shouldShowTooltip = true;
    
    clearTimeout(hideTimeoutFuncID);
    clearTimeout(showTimeoutFuncID);
    showTimeoutFuncID = setTimeout(function () {
      if (shouldShowTooltip) {
        contentTooltip.classList.add('visible');
      }
    }, 100);
  }

  function shouldHideTooltip(activeTarget) {
    return ((tooltipTarget == null || activeTarget != tooltipTarget) && (contentTooltip == null || (activeTarget != contentTooltip && activeTarget != null && activeTarget.closest('.tooltip') == null)));
  }

  function hideTooltip(withDelay) {
    function doHideTooltip() {
      if (false == shouldShowTooltip && tooltip)
        contentTooltip.classList.remove('visible');
      tooltipTarget = null;
      tooltipToTargetRelativePosition = null;
      // TODO: Here is the gotcha
      //       - this cannot be done directly as it will kill the transition animation effects
      //       - not doing it could lead to occupied, overflowing area that will break the auto srinking back the container 
      //         to its content minimum size once the overflowing tooltip got 'invisible'
      //         actually this issue will go away once we limit the tooltip oveflowing in any direction from the window
      setTimeout(function () {
        if (tooltipTarget == null && false == shouldShowTooltip) {
          contentTooltip.innerHTML = '';
          tooltipRenderer.innerHTML = '';
        }
      }, 100);
    }

    shouldShowTooltip = false;

    if (withDelay) {
      clearTimeout(hideTimeoutFuncID);
      hideTimeoutFuncID = setTimeout(function () {
        doHideTooltip();
      }, 25); // Give a small chance to move inside the tooltip (e.g. to allow click on links inside it)
    }
    else
      doHideTooltip();
  }

  function addContentTooltips() {
    var tooltipElements = document.querySelectorAll('.content-tooltip');
    contentTooltip = document.getElementById('tooltip');
    tooltipRenderer = document.getElementById('tooltipRenderer');
    hideTooltip();

    tooltipElements.forEach(function (element) {
      var tooltipText = document.createElement('span');
      tooltipText.className = 'tooltip-text';
      tooltipText.textContent = "";
      element.appendChild(tooltipText);

      element.addEventListener('mouseover', function (event) {
        var isFullPageContent = element.classList.contains('full-content-tooltip');
        var isTextTooltip = element.classList.contains('text-content-tooltip');
        var alignment = (element.classList.contains('tooltip-align-left') ? 'tooltip-align-left' : (element.classList.contains('tooltip-align-center') ? 'tooltip-align-center' : 'tooltip-align-right'));

        tooltipTarget = element;
        tooltipToTargetRelativePosition = null;

        // Load only once per page load
        if (tooltipText.innerHTML === '') {
          var url = element.href;

          function onSuccess(newContent) {
            if (typeof (newContent) === 'object' && 'innerHTML' in newContent)
              newContent = newContent.innerHTML;
            newContent = alterContentForTooltip(newContent, url, isFullPageContent, isTextTooltip);

            if (newContent.length > 0) {              
              tooltipText.innerHTML = newContent; // cache for reuse
              showTooltip(event, tooltipText, alignment, isFullPageContent, isTextTooltip);
            }
            else {
              // Quick navigation from another link with tooltip to this link would keep alive the previous tooltip
              // force close it, as we don't have tooltip for the current and this is the live hovered one.
              hideTooltip(false);
            }
          }

          function onError(error) {
            // Quick navigation from another link with tooltip to this failing link would keep alive the previous tooltip
            // force close it, as we don't have tooltip for the current and this is the live hovered one.
            hideTooltip(false);
            console.error('Error loading the tooltip content!' + error);
          }
          
          if (isTextTooltip) {
            newContent = alterContentForTooltip(element.getAttribute("data-tooltip-text"), null, isFullPageContent, isTextTooltip);
            if (newContent.length > 0) {
              tooltipText.innerHTML = newContent;
              showTooltip(event, tooltipText, alignment, isFullPageContent, isTextTooltip);
            }
          }
          else if (isFullPageContent) {
            loadContentFromUrl(url, newContent => onSuccess(newContent), error => onError(error));
          }
          else {
            loadContentPartFrom(url, newContent => onSuccess(newContent), error => onError(error));
          }
        }
        else
          showTooltip(event, tooltipText, alignment, isFullPageContent, isTextTooltip);
      });
    });

    document.addEventListener('mousemove', function (event) {
      if (shouldHideTooltip(event.target)) {
        if (tooltipTarget)
          hideTooltip(true);
      }
      else {
        clearTimeout(hideTimeoutFuncID);
        shouldShowTooltip = true;
      }
    });

    document.addEventListener('scroll', function (event) {
      if (elementUnderCursor == null || shouldHideTooltip(elementUnderCursor)) {
         hideTooltip(true);
      }
      else if (tooltipTarget) {
        var targetPosition = getElementPositionRelativeToRoot(tooltipTarget);
        var tooltipPosition = getElementPositionRelativeToRoot(contentTooltip);
        var relativPos = { 
          top: tooltipPosition.top - targetPosition.top,
          left: tooltipPosition.left - targetPosition.left
        }

        if (tooltipToTargetRelativePosition == null)
          tooltipToTargetRelativePosition = relativPos;
        else {
          // console.log(" ----");
          // console.log("tooltipPosition - Top: " + tooltipPosition.top + ", Left: " + tooltipPosition.left);
          // console.log("targetPosition - Top: " + targetPosition.top + ", Left: " + targetPosition.left);
          // console.log("relativPos - Top: " + relativPos.top + ", Left: " + relativPos.left);
          // console.log("tooltipToTargetRelativePosition - Top: " + tooltipToTargetRelativePosition.top + ", Left: " + tooltipToTargetRelativePosition.left);

          if (false == comparePositions(relativPos, tooltipToTargetRelativePosition))
            hideTooltip(true);
        }
      }      
    });

    document.addEventListener('mouseover', function (event) {
      elementUnderCursor = event.target;
    });

    window.addEventListener('resize', function () {
      if (tooltipTarget)
        hideTooltip(true);
    });

    window.addEventListener('blur', function () {
      if (tooltipTarget)
        hideTooltip(true);
    });
  }

  // -------------
  // Sticky sidebar
  // -------------

  var initiallySticky = $(".sidebar").hasClass("sticky");
  var stickySideBar = function () {
    var show =
      $(".author__urls-wrapper").find("button").length === 0
        ? $(window).width() > 1024 // width should match $large Sass variable
        : !$(".author__urls-wrapper").find("button").is(":visible");
    if (show) {
      if (initiallySticky) {
        $(".sidebar").addClass("sticky");
      }
    } else {
      $(".sidebar").removeClass("sticky");
    }
  };

  $(window).on("resize", function () {
    stickySideBar();
  });

  // -------------
  // Search
  // -------------

  if (searchEnabled) {
    // Close search screen with Esc key or toggle with predefined hotKey
    $(document).on('keyup', function (event) {
      // Define the desired hotkey (in this case, Ctrl + Shift + F)
      var searchHotkey = { ctrlKey: true, shiftKey: true, key: 'F' };

      if (event.keyCode === 27) {
        if ($(".initial-content").hasClass("is--hidden"))
          toggleSearch(event);
      }
      else if (event.ctrlKey === searchHotkey.ctrlKey &&
        event.shiftKey === searchHotkey.shiftKey &&
        event.key === searchHotkey.key) {
        toggleSearch(event);
      }
    });

    function toggleSearch(event) {
      $(".search-content").toggleClass("is--visible");
      $(".search-content__form").toggleClass("is--visible");      
      $(".initial-content").toggleClass("is--hidden");

      if ($(".initial-content").hasClass("is--hidden")) {
        // set focus on input
        setTimeout(function () {
          var input = $(".search-content__form").find("input");
          input.trigger("focus");
          input.trigger("select");
        }, 100);
      }
      else {
        // set focus back via the initial content otherwise the focus will not get back to the search input once again
        $(".initial-content").find("input").focus();
      }

      if (tooltipTarget)
        hideTooltip(true);
      // NOTE: event.target is not always the toggle here, use it directly instead of the event
      $("#search-button").trigger('blur');
    }

    $("#search-button").on('click', toggleSearch);
  }

  // -------------
  // Startup
  // -------------

  stickySideBar();

  // Make sure everything is initialized correctly on an initial load as well
  // (e.g. when an inner embedded page link is opened directly in a new tab, not via the internal navigational links)
  finalizeContent();

  // Listen for popstate events and update content accordingly
  window.addEventListener('popstate', function () {
    updateContentFromUrl(window.location.pathname);
  });

});
